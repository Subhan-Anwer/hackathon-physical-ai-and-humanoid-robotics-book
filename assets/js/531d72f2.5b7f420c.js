"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[5375],{3120(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"module-2-digital-twin/labs/lab-1-digital-twin-fundamentals","title":"Lab 1: Digital Twin Fundamentals","description":"Overview","source":"@site/docs/module-2-digital-twin/labs/lab-1-digital-twin-fundamentals.md","sourceDirName":"module-2-digital-twin/labs","slug":"/module-2-digital-twin/labs/lab-1-digital-twin-fundamentals","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/labs/lab-1-digital-twin-fundamentals","draft":false,"unlisted":false,"editUrl":"https://github.com/subhan-anwer/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/labs/lab-1-digital-twin-fundamentals.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Lab 1: Digital Twin Fundamentals","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Gazebo for Robotics Simulation","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/chapter-2"},"next":{"title":"Lab 2: Gazebo Environment Setup","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/labs/lab-2-gazebo-environment-setup"}}');var s=i(4848),a=i(8453);const l={title:"Lab 1: Digital Twin Fundamentals",sidebar_position:1},r="Lab 1: Digital Twin Fundamentals",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Lab Setup",id:"lab-setup",level:2},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"Step 1: Create the Physical System Simulator",id:"step-1-create-the-physical-system-simulator",level:3},{value:"Step 2: Create the Digital Twin Node",id:"step-2-create-the-digital-twin-node",level:3},{value:"Step 3: Create Launch File",id:"step-3-create-launch-file",level:3},{value:"Step 4: Compare Fidelity Levels",id:"step-4-compare-fidelity-levels",level:3},{value:"Visualization and Analysis",id:"visualization-and-analysis",level:2},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"What You Learned",id:"what-you-learned",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"lab-1-digital-twin-fundamentals",children:"Lab 1: Digital Twin Fundamentals"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"This lab introduces the fundamental concepts of digital twins by creating a basic simulation with sensor integration and establishing a bridge with ROS 2."}),"\n",(0,s.jsx)(n.h2,{id:"objectives",children:"Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Create a basic digital twin simulation using simple sensors"}),"\n",(0,s.jsx)(n.li,{children:"Implement a physical-digital bridge with ROS 2"}),"\n",(0,s.jsx)(n.li,{children:"Visualize real-time data synchronization"}),"\n",(0,s.jsx)(n.li,{children:"Compare different fidelity levels in simulation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Basic understanding of ROS 2 concepts"}),"\n",(0,s.jsx)(n.li,{children:"Installed ROS 2 environment (Humble Hawksbill or later)"}),"\n",(0,s.jsx)(n.li,{children:"Basic knowledge of simulation environments"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"lab-setup",children:"Lab Setup"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a new ROS 2 workspace for the digital twin project"}),"\n",(0,s.jsx)(n.li,{children:"Set up a basic publisher node that simulates sensor data"}),"\n",(0,s.jsx)(n.li,{children:"Create a subscriber node that represents the digital twin"}),"\n",(0,s.jsx)(n.li,{children:"Establish communication between physical and digital systems"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-create-the-physical-system-simulator",children:"Step 1: Create the Physical System Simulator"}),"\n",(0,s.jsx)(n.p,{children:"Create a ROS 2 node that simulates a physical system with sensors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float32\nimport math\nimport random\n\nclass PhysicalSystemSimulator(Node):\n    def __init__(self):\n        super().__init__('physical_system_simulator')\n        self.publisher_ = self.create_publisher(JointState, 'physical_joint_states', 10)\n        self.timer = self.create_timer(0.1, self.publish_joint_states)  # 10Hz\n        self.time = 0.0\n\n    def publish_joint_states(self):\n        msg = JointState()\n        msg.name = ['joint1', 'joint2']\n        self.time += 0.1\n        msg.position = [math.sin(self.time), math.cos(self.time)]\n        msg.velocity = [math.cos(self.time), -math.sin(self.time)]\n        msg.effort = [random.uniform(-1.0, 1.0), random.uniform(-1.0, 1.0)]\n\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        self.publisher_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = PhysicalSystemSimulator()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-the-digital-twin-node",children:"Step 2: Create the Digital Twin Node"}),"\n",(0,s.jsx)(n.p,{children:"Create a ROS 2 node that receives the sensor data and maintains the digital twin:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom visualization_msgs.msg import Marker\nimport math\n\nclass DigitalTwin(Node):\n    def __init__(self):\n        super().__init__('digital_twin')\n        self.subscription = self.create_subscription(\n            JointState,\n            'physical_joint_states',\n            self.listener_callback,\n            10)\n        self.marker_publisher = self.create_publisher(Marker, 'digital_twin_marker', 10)\n        self.current_joint_states = None\n\n    def listener_callback(self, msg):\n        self.current_joint_states = msg\n        self.get_logger().info(f'Received joint states: pos={msg.position}, vel={msg.velocity}')\n        self.publish_visualization()\n\n    def publish_visualization(self):\n        if self.current_joint_states is not None:\n            marker = Marker()\n            marker.header.frame_id = \"base_link\"\n            marker.header.stamp = self.get_clock().now().to_msg()\n            marker.ns = \"digital_twin\"\n            marker.id = 0\n            marker.type = Marker.SPHERE\n            marker.action = Marker.ADD\n\n            # Position based on joint values\n            marker.pose.position.x = self.current_joint_states.position[0] * 0.5\n            marker.pose.position.y = self.current_joint_states.position[1] * 0.5\n            marker.pose.position.z = 0.0\n            marker.pose.orientation.w = 1.0\n\n            marker.scale.x = 0.1\n            marker.scale.y = 0.1\n            marker.scale.z = 0.1\n\n            marker.color.a = 1.0  # Don't forget to set the alpha!\n            marker.color.r = 0.0\n            marker.color.g = 1.0\n            marker.color.b = 0.0\n\n            self.marker_publisher.publish(marker)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = DigitalTwin()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-create-launch-file",children:"Step 3: Create Launch File"}),"\n",(0,s.jsx)(n.p,{children:"Create a launch file to start both nodes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='digital_twin_lab',\n            executable='physical_system_simulator',\n            name='physical_system_simulator',\n            output='screen'\n        ),\n        Node(\n            package='digital_twin_lab',\n            executable='digital_twin',\n            name='digital_twin',\n            output='screen'\n        )\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-4-compare-fidelity-levels",children:"Step 4: Compare Fidelity Levels"}),"\n",(0,s.jsx)(n.p,{children:"Implement different fidelity models to compare performance:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low Fidelity Model"}),": Simple kinematic representation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Medium Fidelity Model"}),": Includes basic dynamics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High Fidelity Model"}),": Full dynamic simulation with noise modeling"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"visualization-and-analysis",children:"Visualization and Analysis"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Use RViz2 to visualize the digital twin representation"}),"\n",(0,s.jsx)(n.li,{children:"Plot the synchronization between physical and digital systems"}),"\n",(0,s.jsx)(n.li,{children:"Analyze the delay and accuracy of data transmission"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"How does the synchronization delay affect the digital twin's accuracy?"}),"\n",(0,s.jsx)(n.li,{children:"What are the trade-offs between different fidelity levels?"}),"\n",(0,s.jsx)(n.li,{children:"How would you implement bidirectional communication in this system?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-you-learned",children:"What You Learned"}),"\n",(0,s.jsx)(n.p,{children:"In this lab, you implemented a basic digital twin system with real-time data synchronization. You learned how to create both physical simulators and their digital counterparts, and how to visualize and analyze the synchronization between them."})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,i){i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);