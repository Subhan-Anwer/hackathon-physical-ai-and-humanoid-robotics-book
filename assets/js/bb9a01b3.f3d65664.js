"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[881],{5832(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-1-ros2/chapter-1","title":"Chapter 1: ROS 2 Fundamentals","description":"Welcome to the world of ROS 2, the next-generation Robot Operating System that serves as the backbone for modern robotics development. As the \\"nervous system\\" of robotic applications, ROS 2 provides the essential communication infrastructure that enables different components of a robot to work together seamlessly. In this chapter, we\'ll explore the foundational concepts that make ROS 2 the standard framework for robotics development.","source":"@site/docs/module-1-ros2/chapter-1.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-1","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-1","draft":false,"unlisted":false,"editUrl":"https://github.com/subhan-anwer/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-1.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Chapter 1: ROS 2 Fundamentals","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Physical AI and Humanoid Robotics","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/intro"},"next":{"title":"Chapter 2: ROS 2 Ecosystem and Tools","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-2"}}');var r=s(4848),t=s(8453);const o={title:"Chapter 1: ROS 2 Fundamentals",sidebar_position:1},a="Chapter 1: ROS 2 Fundamentals",l={},c=[{value:"ROS 2 vs ROS 1: Understanding the Evolution",id:"ros-2-vs-ros-1-understanding-the-evolution",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"Migration Considerations",id:"migration-considerations",level:3},{value:"Understanding DDS (Data Distribution Service)",id:"understanding-dds-data-distribution-service",level:2},{value:"DDS Architecture",id:"dds-architecture",level:3},{value:"DDS Implementations in ROS 2",id:"dds-implementations-in-ros-2",level:3},{value:"Core ROS 2 Concepts: Nodes, Topics, Services, and Actions",id:"core-ros-2-concepts-nodes-topics-services-and-actions",level:2},{value:"Nodes: The Building Blocks of ROS 2",id:"nodes-the-building-blocks-of-ros-2",level:3},{value:"Topics: Publish-Subscribe Communication",id:"topics-publish-subscribe-communication",level:3},{value:"Services: Request-Response Communication",id:"services-request-response-communication",level:3},{value:"Actions: Goal-Based Communication",id:"actions-goal-based-communication",level:3},{value:"Parameters: Configuration Management",id:"parameters-configuration-management",level:2},{value:"Launch Files: System Configuration",id:"launch-files-system-configuration",level:2},{value:"What You Learned",id:"what-you-learned",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-1-ros-2-fundamentals",children:"Chapter 1: ROS 2 Fundamentals"})}),"\n",(0,r.jsx)(n.p,{children:'Welcome to the world of ROS 2, the next-generation Robot Operating System that serves as the backbone for modern robotics development. As the "nervous system" of robotic applications, ROS 2 provides the essential communication infrastructure that enables different components of a robot to work together seamlessly. In this chapter, we\'ll explore the foundational concepts that make ROS 2 the standard framework for robotics development.'}),"\n",(0,r.jsx)(n.h2,{id:"ros-2-vs-ros-1-understanding-the-evolution",children:"ROS 2 vs ROS 1: Understanding the Evolution"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 represents a significant evolution from its predecessor, addressing many of the limitations that emerged as robotics applications became more complex and safety-critical. The primary motivation for this transition was the need for better real-time performance, improved security, and enhanced support for commercial and industrial applications."}),"\n",(0,r.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Architecture Changes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 1"})," relied on a centralized master-slave architecture with the ROS Master as the single point of failure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2"})," adopts a distributed architecture using DDS (Data Distribution Service) as the middleware, eliminating the need for a central master"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Communication Protocol:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 1"})," used TCPROS/UDPROS for communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2"})," uses DDS, which provides better real-time performance and quality of service controls"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Security:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 1"})," had minimal security features"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2"})," includes built-in security mechanisms including authentication, encryption, and access control"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Real-time Support:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 1"})," was not designed with real-time constraints in mind"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ROS 2"})," provides better support for real-time systems with deterministic behavior"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"migration-considerations",children:"Migration Considerations"}),"\n",(0,r.jsx)(n.p,{children:"When moving from ROS 1 to ROS 2, developers need to consider several changes:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Package structure remains similar but some APIs have changed"}),"\n",(0,r.jsx)(n.li,{children:"Launch files use a new Python-based format"}),"\n",(0,r.jsx)(n.li,{children:"Message\u548c\u670d\u52a1 definitions remain compatible but client library APIs differ"}),"\n",(0,r.jsx)(n.li,{children:"Testing frameworks have been updated"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"understanding-dds-data-distribution-service",children:"Understanding DDS (Data Distribution Service)"}),"\n",(0,r.jsx)(n.p,{children:"DDS (Data Distribution Service) is the middleware that powers ROS 2's communication system. It's a standardized protocol designed for real-time, high-performance systems, making it ideal for robotics applications where timing and reliability are critical."}),"\n",(0,r.jsx)(n.h3,{id:"dds-architecture",children:"DDS Architecture"}),"\n",(0,r.jsx)(n.p,{children:"DDS implements a publish-subscribe communication pattern where:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Publishers"})," send data to specific topics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subscribers"})," receive data from topics they're interested in"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DDS Implementation"})," handles the discovery, routing, and delivery of messages"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The DDS specification defines several Quality of Service (QoS) policies that allow fine-tuning of communication behavior, which we'll explore in detail later in this module."}),"\n",(0,r.jsx)(n.h3,{id:"dds-implementations-in-ros-2",children:"DDS Implementations in ROS 2"}),"\n",(0,r.jsx)(n.p,{children:"ROS 2 supports multiple DDS implementations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fast DDS"})," (formerly FastRTPS) - Default implementation from eProsima"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cyclone DDS"})," - High-performance implementation from Eclipse"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RTI Connext DDS"})," - Commercial implementation from RTI"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"OpenSplice DDS"})," - Open-source implementation"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each implementation has its own strengths and is suitable for different use cases, from embedded systems to high-performance computing clusters."}),"\n",(0,r.jsx)(n.h2,{id:"core-ros-2-concepts-nodes-topics-services-and-actions",children:"Core ROS 2 Concepts: Nodes, Topics, Services, and Actions"}),"\n",(0,r.jsx)(n.h3,{id:"nodes-the-building-blocks-of-ros-2",children:"Nodes: The Building Blocks of ROS 2"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"node"})," is an executable process that works as part of a ROS 2 system. It's the fundamental unit of computation in ROS 2. Nodes contain the application logic and communicate with other nodes through topics, services, and actions."]}),"\n",(0,r.jsx)(n.p,{children:"Here's a simple example of creating a node in Python:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\n\r\nclass MinimalNode(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_publisher')\r\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = 'Hello World: %d' % self.i\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\r\n        self.i += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    minimal_publisher = MinimalNode()\r\n    rclpy.spin(minimal_publisher)\r\n    minimal_publisher.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"topics-publish-subscribe-communication",children:"Topics: Publish-Subscribe Communication"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Topics"})," enable asynchronous, many-to-many communication between nodes using a publish-subscribe pattern. Publishers send messages to topics, and subscribers receive messages from topics they're listening to."]}),"\n",(0,r.jsx)(n.p,{children:"Key characteristics of topics:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous"}),": Publishers and subscribers don't need to be synchronized"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Many-to-many"}),": Multiple publishers can send to the same topic, and multiple subscribers can listen to the same topic"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unidirectional"}),": Communication flows in one direction from publisher to subscriber"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Typed"}),": Each topic has a specific message type that defines its structure"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"services-request-response-communication",children:"Services: Request-Response Communication"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Services"})," provide synchronous, request-response communication between nodes. A client sends a request to a service, and the service processes the request and returns a response."]}),"\n",(0,r.jsx)(n.p,{children:"Service communication is:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronous"}),": The client waits for the service to respond"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"One-to-one"}),": One client communicates with one service server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bidirectional"}),": Request goes one way, response goes the other way"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Typed"}),": Both request and response have defined message types"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"actions-goal-based-communication",children:"Actions: Goal-Based Communication"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Actions"})," are used for long-running tasks that provide feedback and can be canceled. They combine the features of services and topics, providing:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": Request sent to start a task"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Continuous updates on task progress"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Final outcome when task completes"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Actions are ideal for tasks like navigation, where you want to send a goal (navigate to position X), receive feedback (current progress), and get a result (success/failure)."}),"\n",(0,r.jsx)(n.h2,{id:"parameters-configuration-management",children:"Parameters: Configuration Management"}),"\n",(0,r.jsxs)(n.p,{children:["ROS 2 ",(0,r.jsx)(n.strong,{children:"parameters"})," provide a way to configure nodes at runtime. Parameters are key-value pairs that can be set when launching nodes or changed during execution."]}),"\n",(0,r.jsx)(n.p,{children:"Parameters support various data types:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Integers and floating-point numbers"}),"\n",(0,r.jsx)(n.li,{children:"Strings"}),"\n",(0,r.jsx)(n.li,{children:"Booleans"}),"\n",(0,r.jsx)(n.li,{children:"Lists and arrays"}),"\n",(0,r.jsx)(n.li,{children:"Dictionaries"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Example of parameter usage in a node:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class ParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('parameter_node')\r\n\r\n        # Declare parameters with default values\r\n        self.declare_parameter('robot_name', 'turtlebot')\r\n        self.declare_parameter('max_speed', 1.0)\r\n        self.declare_parameter('sensors_enabled', True)\r\n\r\n        # Access parameter values\r\n        robot_name = self.get_parameter('robot_name').value\r\n        max_speed = self.get_parameter('max_speed').value\r\n        sensors_enabled = self.get_parameter('sensors_enabled').value\n"})}),"\n",(0,r.jsx)(n.h2,{id:"launch-files-system-configuration",children:"Launch Files: System Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["ROS 2 uses ",(0,r.jsx)(n.strong,{children:"launch files"})," to start multiple nodes with specific configurations. Unlike ROS 1's XML-based launch files, ROS 2 uses Python-based launch files, providing more flexibility and programmability."]}),"\n",(0,r.jsx)(n.p,{children:"Example launch file:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='turtlesim',\r\n            executable='turtlesim_node',\r\n            name='sim'\r\n        ),\r\n        Node(\r\n            package='turtlesim',\r\n            executable='turtle_teleop_key',\r\n            name='teleop',\r\n            remappings=[\r\n                ('/turtle1/cmd_vel', '/cmd_vel'),\r\n            ]\r\n        ),\r\n        Node(\r\n            package='demo_nodes_py',\r\n            executable='listener',\r\n            name='listener'\r\n        )\r\n    ])\n"})}),"\n",(0,r.jsx)(n.p,{children:"Launch files can include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Node definitions with parameters and remappings"}),"\n",(0,r.jsx)(n.li,{children:"Conditional logic for different configurations"}),"\n",(0,r.jsx)(n.li,{children:"Launch file composition (including other launch files)"}),"\n",(0,r.jsx)(n.li,{children:"Parameter file loading"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"what-you-learned",children:"What You Learned"}),"\n",(0,r.jsx)(n.p,{children:"In this chapter, you've gained a foundational understanding of ROS 2's core concepts and architecture. You now understand how ROS 2 differs from ROS 1, the role of DDS as the middleware, and the fundamental communication patterns: nodes, topics, services, and actions. You've also learned about parameter management and launch file configuration, which are essential for building complex robotic systems. These concepts form the basis for all ROS 2 applications and will be expanded upon in the following chapters."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);