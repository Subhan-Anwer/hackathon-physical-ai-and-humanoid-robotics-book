"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[5756],{4948(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-2-digital-twin/chapter-3","title":"Chapter 3: Robot Modeling with URDF & Sensors","description":"Introduction","source":"@site/docs/module-2-digital-twin/chapter-3.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/chapter-3","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/subhan-anwer/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/chapter-3.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Chapter 3: Robot Modeling with URDF & Sensors","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 1: What is a Digital Twin?","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/chapter-1"},"next":{"title":"Chapter 4: Unity for High-Fidelity Interaction","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-2-digital-twin/chapter-4"}}');var a=i(4848),o=i(8453);const t={title:"Chapter 3: Robot Modeling with URDF & Sensors",sidebar_position:1},s="Chapter 3: Robot Modeling with URDF & Sensors",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"URDF XML Structure and Element Hierarchy",id:"urdf-xml-structure-and-element-hierarchy",level:2},{value:"Root Structure",id:"root-structure",level:3},{value:"Link Elements",id:"link-elements",level:3},{value:"Joint Elements",id:"joint-elements",level:3},{value:"Links, Joints, and Transmissions in Robot Modeling",id:"links-joints-and-transmissions-in-robot-modeling",level:2},{value:"Links",id:"links",level:3},{value:"Joint Types",id:"joint-types",level:3},{value:"Transmissions",id:"transmissions",level:3},{value:"Kinematic and Dynamic Properties Definition",id:"kinematic-and-dynamic-properties-definition",level:2},{value:"Kinematic Properties",id:"kinematic-properties",level:3},{value:"Dynamic Properties",id:"dynamic-properties",level:3},{value:"Visual and Collision Properties",id:"visual-and-collision-properties",level:2},{value:"Visual Properties",id:"visual-properties",level:3},{value:"Collision Properties",id:"collision-properties",level:3},{value:"Sensor Integration within Robot Models",id:"sensor-integration-within-robot-models",level:2},{value:"Camera Sensor Integration",id:"camera-sensor-integration",level:3},{value:"IMU Sensor Integration",id:"imu-sensor-integration",level:3},{value:"LIDAR Sensor Integration",id:"lidar-sensor-integration",level:3},{value:"Xacro Macros for Complex Model Generation",id:"xacro-macros-for-complex-model-generation",level:2},{value:"Basic Xacro Structure",id:"basic-xacro-structure",level:3},{value:"Conditional Statements",id:"conditional-statements",level:3},{value:"What You Learned",id:"what-you-learned",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-3-robot-modeling-with-urdf--sensors",children:"Chapter 3: Robot Modeling with URDF & Sensors"})}),"\n",(0,a.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(e.p,{children:"Unified Robot Description Format (URDF) is the standard XML-based format for describing robot models in ROS. It defines the kinematic and dynamic properties of robots, including their links, joints, and associated sensors. This chapter explores the structure of URDF files, the process of creating robot models, and the integration of sensors into robot descriptions for simulation and real-world applications."}),"\n",(0,a.jsx)(e.h2,{id:"urdf-xml-structure-and-element-hierarchy",children:"URDF XML Structure and Element Hierarchy"}),"\n",(0,a.jsx)(e.p,{children:"URDF follows a hierarchical structure where a robot is composed of links connected by joints. The fundamental elements include:"}),"\n",(0,a.jsx)(e.h3,{id:"root-structure",children:"Root Structure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<robot name="robot_name">\n  \x3c!-- Links, joints, and other elements --\x3e\n</robot>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"link-elements",children:"Link Elements"}),"\n",(0,a.jsx)(e.p,{children:"Links represent rigid bodies in the robot model and contain three main sub-elements:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<link name="link_name">\n  \x3c!-- Visual properties for display --\x3e\n  <visual>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="1 1 1"/>\n    </geometry>\n    <material name="color">\n      <color rgba="0.8 0.2 0.2 1.0"/>\n    </material>\n  </visual>\n\n  \x3c!-- Collision properties for physics simulation --\x3e\n  <collision>\n    <origin xyz="0 0 0" rpy="0 0 0"/>\n    <geometry>\n      <box size="1 1 1"/>\n    </geometry>\n  </collision>\n\n  \x3c!-- Inertial properties for dynamics --\x3e\n  <inertial>\n    <mass value="1.0"/>\n    <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n  </inertial>\n</link>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"joint-elements",children:"Joint Elements"}),"\n",(0,a.jsx)(e.p,{children:"Joints define the kinematic and dynamic relationships between links:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<joint name="joint_name" type="joint_type">\n  <parent link="parent_link_name"/>\n  <child link="child_link_name"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n</joint>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"links-joints-and-transmissions-in-robot-modeling",children:"Links, Joints, and Transmissions in Robot Modeling"}),"\n",(0,a.jsx)(e.h3,{id:"links",children:"Links"}),"\n",(0,a.jsx)(e.p,{children:"Links represent the rigid bodies of a robot. Each link can have:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual"}),": Defines how the link appears in simulation and visualization"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Collision"}),": Defines the collision geometry for physics simulation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Inertial"}),": Defines mass, center of mass, and inertia tensor for dynamics"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"joint-types",children:"Joint Types"}),"\n",(0,a.jsx)(e.p,{children:"URDF supports several joint types:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Revolute"}),": Rotational joint with limited range"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Continuous"}),": Rotational joint without limits"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Prismatic"}),": Linear sliding joint with limits"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fixed"}),": No movement between links"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Floating"}),": 6 DOF movement"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Planar"}),": Movement in a plane"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"transmissions",children:"Transmissions"}),"\n",(0,a.jsx)(e.p,{children:"Transmissions define how actuators connect to joints:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<transmission name="tran1">\n  <type>transmission_interface/SimpleTransmission</type>\n  <joint name="joint1">\n    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n  </joint>\n  <actuator name="motor1">\n    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n    <mechanicalReduction>1</mechanicalReduction>\n  </actuator>\n</transmission>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"kinematic-and-dynamic-properties-definition",children:"Kinematic and Dynamic Properties Definition"}),"\n",(0,a.jsx)(e.h3,{id:"kinematic-properties",children:"Kinematic Properties"}),"\n",(0,a.jsx)(e.p,{children:"Kinematic properties define the geometric relationships and movement constraints:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<joint name="shoulder_joint" type="revolute">\n  <parent link="torso"/>\n  <child link="upper_arm"/>\n  <origin xyz="0.0 0.2 0.3" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit lower="-1.57" upper="1.57" effort="100" velocity="1"/>\n  <dynamics damping="0.1" friction="0.0"/>\n</joint>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"dynamic-properties",children:"Dynamic Properties"}),"\n",(0,a.jsx)(e.p,{children:"Dynamic properties define mass, inertia, and other physical characteristics:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<inertial>\n  <mass value="2.0"/>\n  <origin xyz="0.0 0.0 0.1" rpy="0 0 0"/>\n  <inertia\n    ixx="0.02" ixy="0.0" ixz="0.0"\n    iyy="0.03" iyz="0.0"\n    izz="0.01"/>\n</inertial>\n'})}),"\n",(0,a.jsx)(e.p,{children:"For complex shapes, the inertia can be calculated using:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"ixx"}),", ",(0,a.jsx)(e.code,{children:"iyy"}),", ",(0,a.jsx)(e.code,{children:"izz"}),": Moments of inertia about the x, y, z axes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.code,{children:"ixy"}),", ",(0,a.jsx)(e.code,{children:"ixz"}),", ",(0,a.jsx)(e.code,{children:"iyz"}),": Products of inertia"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"visual-and-collision-properties",children:"Visual and Collision Properties"}),"\n",(0,a.jsx)(e.h3,{id:"visual-properties",children:"Visual Properties"}),"\n",(0,a.jsx)(e.p,{children:"Visual elements define how the robot appears in simulation and visualization tools:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<visual>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    \x3c!-- Box geometry --\x3e\n    <box size="0.1 0.1 0.2"/>\n\n    \x3c!-- Cylinder geometry --\x3e\n    <cylinder radius="0.05" length="0.1"/>\n\n    \x3c!-- Sphere geometry --\x3e\n    <sphere radius="0.05"/>\n\n    \x3c!-- Mesh geometry --\x3e\n    <mesh filename="package://robot_description/meshes/link1.dae" scale="1 1 1"/>\n  </geometry>\n  <material name="red">\n    <color rgba="0.8 0.2 0.2 1.0"/>\n  </material>\n</visual>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"collision-properties",children:"Collision Properties"}),"\n",(0,a.jsx)(e.p,{children:"Collision elements define the geometry used for collision detection:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<collision>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <geometry>\n    <box size="0.1 0.1 0.2"/>\n  </geometry>\n</collision>\n'})}),"\n",(0,a.jsx)(e.p,{children:"Collision geometry is often simplified compared to visual geometry for computational efficiency."}),"\n",(0,a.jsx)(e.h2,{id:"sensor-integration-within-robot-models",children:"Sensor Integration within Robot Models"}),"\n",(0,a.jsx)(e.p,{children:"Sensors can be integrated into URDF models to define their mounting positions and properties:"}),"\n",(0,a.jsx)(e.h3,{id:"camera-sensor-integration",children:"Camera Sensor Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<link name="camera_link">\n  <visual>\n    <geometry>\n      <box size="0.02 0.08 0.04"/>\n    </geometry>\n    <material name="black"/>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.02 0.08 0.04"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.1"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\n  </inertial>\n</link>\n\n<joint name="camera_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="camera_link"/>\n  <origin xyz="0.1 0 0.1" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="camera_link">\n  <sensor type="camera" name="camera1">\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>600</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.1</near>\n        <far>100</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_optical_frame</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"imu-sensor-integration",children:"IMU Sensor Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<link name="imu_link">\n  <inertial>\n    <mass value="0.01"/>\n    <inertia ixx="0.000001" ixy="0" ixz="0" iyy="0.000001" iyz="0" izz="0.000001"/>\n  </inertial>\n</link>\n\n<joint name="imu_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="imu_link"/>\n  <origin xyz="0 0 0.1" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="imu_link">\n  <sensor type="imu" name="imu_sensor">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <visualize>false</visualize>\n    <imu>\n      <angular_velocity>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>2e-4</stddev>\n          </noise>\n        </z>\n      </angular_velocity>\n      <linear_acceleration>\n        <x>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n          </noise>\n        </x>\n        <y>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n          </noise>\n        </y>\n        <z>\n          <noise type="gaussian">\n            <mean>0.0</mean>\n            <stddev>1.7e-2</stddev>\n          </noise>\n        </z>\n      </linear_acceleration>\n    </imu>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"lidar-sensor-integration",children:"LIDAR Sensor Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<link name="lidar_link">\n  <visual>\n    <geometry>\n      <cylinder radius="0.05" length="0.04"/>\n    </geometry>\n    <material name="black"/>\n  </visual>\n  <collision>\n    <geometry>\n      <cylinder radius="0.05" length="0.04"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="0.2"/>\n    <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.002"/>\n  </inertial>\n</link>\n\n<joint name="lidar_joint" type="fixed">\n  <parent link="base_link"/>\n  <child link="lidar_link"/>\n  <origin xyz="0 0 0.2" rpy="0 0 0"/>\n</joint>\n\n<gazebo reference="lidar_link">\n  <sensor type="ray" name="lidar_sensor">\n    <always_on>true</always_on>\n    <visualize>true</visualize>\n    <update_rate>10</update_rate>\n    <ray>\n      <scan>\n        <horizontal>\n          <samples>720</samples>\n          <resolution>1</resolution>\n          <min_angle>-3.14159</min_angle>\n          <max_angle>3.14159</max_angle>\n        </horizontal>\n      </scan>\n      <range>\n        <min>0.1</min>\n        <max>30.0</max>\n        <resolution>0.01</resolution>\n      </range>\n    </ray>\n    <plugin name="lidar_controller" filename="libgazebo_ros_laser.so">\n      <topic_name>scan</topic_name>\n      <frame_name>lidar_link</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"xacro-macros-for-complex-model-generation",children:"Xacro Macros for Complex Model Generation"}),"\n",(0,a.jsx)(e.p,{children:"Xacro (XML Macros) extends URDF with features like constants, properties, and macros:"}),"\n",(0,a.jsx)(e.h3,{id:"basic-xacro-structure",children:"Basic Xacro Structure"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="robot_name">\n\n  \x3c!-- Constants --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931"/>\n  <xacro:property name="wheel_radius" value="0.1"/>\n  <xacro:property name="wheel_width" value="0.05"/>\n\n  \x3c!-- Macros --\x3e\n  <xacro:macro name="wheel" params="prefix parent xyz rpy">\n    <link name="${prefix}_wheel">\n      <visual>\n        <origin xyz="0 0 0" rpy="0 0 0"/>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n      </visual>\n      <collision>\n        <origin xyz="0 0 0" rpy="${M_PI/2} 0 0"/>\n        <geometry>\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\n        </geometry>\n      </collision>\n      <inertial>\n        <mass value="0.5"/>\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.02"/>\n      </inertial>\n    </link>\n\n    <joint name="${prefix}_wheel_joint" type="continuous">\n      <parent link="${parent}"/>\n      <child link="${prefix}_wheel"/>\n      <origin xyz="${xyz}" rpy="${rpy}"/>\n      <axis xyz="0 1 0"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Using the macro --\x3e\n  <xacro:wheel prefix="front_left" parent="base_link" xyz="0.2 0.2 0" rpy="0 0 0"/>\n  <xacro:wheel prefix="front_right" parent="base_link" xyz="0.2 -0.2 0" rpy="0 0 0"/>\n  <xacro:wheel prefix="rear_left" parent="base_link" xyz="-0.2 0.2 0" rpy="0 0 0"/>\n  <xacro:wheel prefix="rear_right" parent="base_link" xyz="-0.2 -0.2 0" rpy="0 0 0"/>\n\n</robot>\n'})}),"\n",(0,a.jsx)(e.h3,{id:"conditional-statements",children:"Conditional Statements"}),"\n",(0,a.jsx)(e.p,{children:"Xacro supports conditional statements for flexible model generation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-xml",children:'<xacro:property name="has_camera" value="true"/>\n\n<xacro:if value="${has_camera}">\n  <link name="camera_mount">\n    <visual>\n      <geometry>\n        <box size="0.02 0.08 0.04"/>\n      </geometry>\n    </visual>\n  </link>\n</xacro:if>\n'})}),"\n",(0,a.jsx)(e.h2,{id:"what-you-learned",children:"What You Learned"}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, you learned about the structure and elements of URDF robot descriptions, including links, joints, and transmissions. You explored how to define kinematic and dynamic properties, configure visual and collision properties, and integrate various sensor types into robot models. You also discovered how to use Xacro macros to create complex, parameterized robot models efficiently. This knowledge is essential for creating accurate robot models for simulation and real-world applications."})]})}function m(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>t,x:()=>s});var r=i(6540);const a={},o=r.createContext(a);function t(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),r.createElement(o.Provider,{value:e},n.children)}}}]);