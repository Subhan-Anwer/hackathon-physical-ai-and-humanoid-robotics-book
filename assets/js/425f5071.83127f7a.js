"use strict";(globalThis.webpackChunksite=globalThis.webpackChunksite||[]).push([[6315],{8453(e,i,n){n.d(i,{R:()=>o,x:()=>l});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}},9058(e,i,n){n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module-1-ros2/chapter-3","title":"Chapter 3: Advanced ROS 2 Concepts","description":"As you advance in your ROS 2 journey, understanding the more sophisticated concepts becomes crucial for building robust, efficient, and safe robotic systems. This chapter delves into advanced topics that are essential for professional robotics development, including Quality of Service policies, real-time considerations, multi-robot systems, and security concepts.","source":"@site/docs/module-1-ros2/chapter-3.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-3","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/subhan-anwer/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Chapter 3: Advanced ROS 2 Concepts","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: ROS 2 Ecosystem and Tools","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/chapter-2"},"next":{"title":"Lab 1: Installation and Basic Publisher/Subscriber","permalink":"/hackathon-physical-ai-and-humanoid-robotics-book/docs/module-1-ros2/labs/lab-1-installation-and-pubsub"}}');var t=n(4848),r=n(8453);const o={title:"Chapter 3: Advanced ROS 2 Concepts",sidebar_position:3},l="Chapter 3: Advanced ROS 2 Concepts",c={},a=[{value:"Quality of Service (QoS) Policies",id:"quality-of-service-qos-policies",level:2},{value:"Understanding QoS Profiles",id:"understanding-qos-profiles",level:3},{value:"Practical QoS Examples",id:"practical-qos-examples",level:3},{value:"QoS Compatibility Rules",id:"qos-compatibility-rules",level:3},{value:"Real-time Considerations in ROS 2",id:"real-time-considerations-in-ros-2",level:2},{value:"Real-time Scheduling",id:"real-time-scheduling",level:3},{value:"Setting Real-time Priority",id:"setting-real-time-priority",level:3},{value:"Real-time Configuration Tips",id:"real-time-configuration-tips",level:3},{value:"Multi-robot Systems",id:"multi-robot-systems",level:2},{value:"Namespaces and Remapping",id:"namespaces-and-remapping",level:3},{value:"Robot Discovery and Communication",id:"robot-discovery-and-communication",level:3},{value:"Coordination Patterns",id:"coordination-patterns",level:3},{value:"Security Concepts in ROS 2",id:"security-concepts-in-ros-2",level:2},{value:"Authentication",id:"authentication",level:3},{value:"Encryption",id:"encryption",level:3},{value:"Access Control",id:"access-control",level:3},{value:"Implementing Security",id:"implementing-security",level:3},{value:"Security Best Practices",id:"security-best-practices",level:3},{value:"What You Learned",id:"what-you-learned",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"chapter-3-advanced-ros-2-concepts",children:"Chapter 3: Advanced ROS 2 Concepts"})}),"\n",(0,t.jsx)(i.p,{children:"As you advance in your ROS 2 journey, understanding the more sophisticated concepts becomes crucial for building robust, efficient, and safe robotic systems. This chapter delves into advanced topics that are essential for professional robotics development, including Quality of Service policies, real-time considerations, multi-robot systems, and security concepts."}),"\n",(0,t.jsx)(i.h2,{id:"quality-of-service-qos-policies",children:"Quality of Service (QoS) Policies"}),"\n",(0,t.jsx)(i.p,{children:"Quality of Service (QoS) policies are a fundamental feature of ROS 2 that allow you to control how messages are delivered between nodes. Since ROS 2 uses DDS (Data Distribution Service) as its middleware, QoS policies provide fine-grained control over communication behavior, which is critical for safety-critical and real-time applications."}),"\n",(0,t.jsx)(i.h3,{id:"understanding-qos-profiles",children:"Understanding QoS Profiles"}),"\n",(0,t.jsx)(i.p,{children:"QoS policies are grouped into profiles that define how topics and services behave. Each policy addresses a specific aspect of communication:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Reliability Policy:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"RELIABLE"}),": Ensures all messages are delivered, with retries if necessary (similar to TCP)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"BEST_EFFORT"}),": Messages are sent without guarantees of delivery (similar to UDP)"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Use RELIABLE for critical data like control commands or safety information, and BEST_EFFORT for high-frequency data like sensor streams where some loss is acceptable."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Durability Policy:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"TRANSIENT_LOCAL"}),": Late-joining subscribers receive the last known value for the topic"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"VOLATILE"}),": Late-joining subscribers only receive new messages (default)"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"TRANSIENT_LOCAL is useful for topics that contain state information that new subscribers need to know immediately."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"History Policy:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"KEEP_LAST"}),": Store a specific number of most recent messages"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"KEEP_ALL"}),": Store all messages (limited by system resources)"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Depth Parameter:"}),"\nControls how many messages are stored when using KEEP_LAST history policy."]}),"\n",(0,t.jsx)(i.h3,{id:"practical-qos-examples",children:"Practical QoS Examples"}),"\n",(0,t.jsx)(i.p,{children:"Here's how to implement QoS policies in Python:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\nfrom std_msgs.msg import String\n\nclass QoSNode(Node):\n    def __init__(self):\n        super().__init__('qos_node')\n\n        # Create a QoS profile for critical control messages\n        control_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Create a QoS profile for sensor data\n        sensor_qos = QoSProfile(\n            depth=5,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            history=HistoryPolicy.KEEP_LAST\n        )\n\n        # Create publishers with different QoS profiles\n        self.control_publisher = self.create_publisher(\n            String, 'control_commands', control_qos\n        )\n        self.sensor_publisher = self.create_publisher(\n            String, 'sensor_data', sensor_qos\n        )\n\n        # Create subscribers with matching QoS profiles\n        self.control_subscriber = self.create_subscription(\n            String, 'control_commands',\n            self.control_callback, control_qos\n        )\n        self.sensor_subscriber = self.create_subscription(\n            String, 'sensor_data',\n            self.sensor_callback, sensor_qos\n        )\n\n    def control_callback(self, msg):\n        self.get_logger().info(f'Control message: {msg.data}')\n\n    def sensor_callback(self, msg):\n        self.get_logger().info(f'Sensor message: {msg.data}')\n"})}),"\n",(0,t.jsx)(i.h3,{id:"qos-compatibility-rules",children:"QoS Compatibility Rules"}),"\n",(0,t.jsx)(i.p,{children:"When publishers and subscribers have different QoS policies, ROS 2 follows specific compatibility rules:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Publishers and subscribers must have compatible policies to communicate"}),"\n",(0,t.jsx)(i.li,{children:"The most restrictive policy between publisher and subscriber is used"}),"\n",(0,t.jsx)(i.li,{children:"Incompatible policies result in no communication"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"real-time-considerations-in-ros-2",children:"Real-time Considerations in ROS 2"}),"\n",(0,t.jsx)(i.p,{children:"Real-time systems have strict timing requirements where tasks must complete within deterministic time bounds. While ROS 2 wasn't designed specifically as a real-time system, it provides features that enable real-time capabilities."}),"\n",(0,t.jsx)(i.h3,{id:"real-time-scheduling",children:"Real-time Scheduling"}),"\n",(0,t.jsx)(i.p,{children:"Linux provides several scheduling policies for real-time applications:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"SCHED_FIFO"}),": First-in, first-out scheduling with preemption"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"SCHED_RR"}),": Round-robin scheduling with time slices"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"SCHED_DEADLINE"}),": Deadline-based scheduling (requires kernel support)"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"setting-real-time-priority",children:"Setting Real-time Priority"}),"\n",(0,t.jsx)(i.p,{children:"To run ROS 2 nodes with real-time priority:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"import os\nimport ctypes\nfrom ctypes import Structure, c_int, c_short, c_char\nimport rclpy\nfrom rclpy.node import Node\n\nclass RealTimeNode(Node):\n    def __init__(self):\n        super().__init__('realtime_node')\n\n        # Set real-time priority (requires appropriate permissions)\n        self.set_realtime_priority(80)  # Priority 1-99\n\n    def set_realtime_priority(self, priority):\n        # Load libc\n        libc = ctypes.CDLL('libc.so.6')\n\n        # Define sched_param structure\n        class SchedParam(Structure):\n            _fields_ = [('sched_priority', c_int)]\n\n        param = SchedParam()\n        param.sched_priority = priority\n\n        # Set scheduling policy to SCHED_FIFO\n        result = libc.sched_setscheduler(0, 1, ctypes.byref(param))\n        if result != 0:\n            self.get_logger().error('Failed to set real-time priority')\n"})}),"\n",(0,t.jsx)(i.h3,{id:"real-time-configuration-tips",children:"Real-time Configuration Tips"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"System Configuration:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Disable CPU frequency scaling"}),"\n",(0,t.jsx)(i.li,{children:"Disable address space layout randomization (ASLR)"}),"\n",(0,t.jsx)(i.li,{children:"Configure memory locking to prevent page faults"}),"\n",(0,t.jsx)(i.li,{children:"Use real-time kernel patches if needed"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Application Design:"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Minimize dynamic memory allocation"}),"\n",(0,t.jsx)(i.li,{children:"Use memory pools to avoid allocation during real-time execution"}),"\n",(0,t.jsx)(i.li,{children:"Avoid blocking operations"}),"\n",(0,t.jsx)(i.li,{children:"Keep callback functions short and deterministic"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"multi-robot-systems",children:"Multi-robot Systems"}),"\n",(0,t.jsx)(i.p,{children:"ROS 2 provides excellent support for multi-robot systems, where multiple robots need to coordinate and communicate with each other. This is achieved through ROS 2's distributed architecture."}),"\n",(0,t.jsx)(i.h3,{id:"namespaces-and-remapping",children:"Namespaces and Remapping"}),"\n",(0,t.jsx)(i.p,{children:"Each robot can operate in its own namespace to avoid topic conflicts:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass MultiRobotNode(Node):\n    def __init__(self):\n        # Initialize with namespace for this robot\n        super().__init__('robot_controller', namespace='robot1')\n\n        # Topics will now be /robot1/topic_name\n        self.publisher = self.create_publisher(\n            String, 'cmd_vel', 10\n        )\n\n        # Global topics (outside namespace) for inter-robot communication\n        self.global_publisher = self.create_publisher(\n            String, '/global_topic', 10\n        )\n"})}),"\n",(0,t.jsx)(i.h3,{id:"robot-discovery-and-communication",children:"Robot Discovery and Communication"}),"\n",(0,t.jsx)(i.p,{children:"ROS 2's DDS-based discovery mechanism automatically handles robot discovery within the same domain:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"# Set different domain IDs for different robot teams\nimport os\nos.environ['ROS_DOMAIN_ID'] = '1'  # Team 1\n# os.environ['ROS_DOMAIN_ID'] = '2'  # Team 2\n\ndef main(args=None):\n    # Set domain ID before initializing\n    rclpy.init(args=args)\n    node = MultiRobotNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(i.h3,{id:"coordination-patterns",children:"Coordination Patterns"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Leader-Follower Pattern:"}),"\nOne robot acts as coordinator while others follow its commands."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Distributed Coordination:"}),"\nAll robots participate in decision-making through consensus algorithms."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Hierarchical Control:"}),"\nHigher-level nodes coordinate multiple lower-level robot controllers."]}),"\n",(0,t.jsx)(i.h2,{id:"security-concepts-in-ros-2",children:"Security Concepts in ROS 2"}),"\n",(0,t.jsx)(i.p,{children:"Security is critical for ROS 2 systems, especially in commercial and industrial applications. ROS 2 includes DDS Security, which provides comprehensive security features."}),"\n",(0,t.jsx)(i.h3,{id:"authentication",children:"Authentication"}),"\n",(0,t.jsx)(i.p,{children:"Authentication ensures that only authorized nodes can join the ROS 2 network:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Identity Certificate"}),": Verifies the identity of nodes"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"CA Certificate"}),": Certificate Authority that signs identity certificates"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Certificate Validation"}),": Ensures certificates haven't been revoked"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"encryption",children:"Encryption"}),"\n",(0,t.jsx)(i.p,{children:"ROS 2 provides multiple levels of encryption:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Transport Encryption:"}),"\nEncrypts all data in transit between nodes."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Message Encryption:"}),"\nEncrypts individual messages for end-to-end security."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Signing:"}),"\nProvides message authentication and integrity verification."]}),"\n",(0,t.jsx)(i.h3,{id:"access-control",children:"Access Control"}),"\n",(0,t.jsx)(i.p,{children:"Access control policies define what nodes can communicate with each other:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Partition Security"}),": Restricts which nodes can access specific topics"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Topic Security"}),": Controls access to individual topics"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Service Security"}),": Controls access to services"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"implementing-security",children:"Implementing Security"}),"\n",(0,t.jsx)(i.p,{children:"To enable security in ROS 2:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Generate certificates and keys"}),"\n",(0,t.jsx)(i.li,{children:"Configure security files"}),"\n",(0,t.jsx)(i.li,{children:"Set environment variables"}),"\n",(0,t.jsx)(i.li,{children:"Launch nodes with security enabled"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Example security configuration:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-xml",children:'\x3c!-- security_permissions.xml --\x3e\n<dds xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n     xsi:noNamespaceSchemaLocation="http://www.omg.org/spec/DDS-SECURITY/20170901/dcps.xsd">\n    <permissions>\n        <grant name="RobotNode">\n            <subject_name>CN=Robot,O=Robotics,C=US</subject_name>\n            <validity>\n                <not_before>2023-01-01T00:00:00</not_before>\n                <not_after>2030-01-01T00:00:00</not_after>\n            </validity>\n            <allow_rule>\n                <domains>\n                    <id_range>\n                        <min>0</min>\n                        <max>232</max>\n                    </id_range>\n                </domains>\n                <publish>\n                    <topics>\n                        <topic>cmd_vel</topic>\n                        <topic>sensor_data</topic>\n                    </topics>\n                </publish>\n                <subscribe>\n                    <topics>\n                        <topic>cmd_vel</topic>\n                        <topic>sensor_data</topic>\n                    </topics>\n                </subscribe>\n            </allow_rule>\n        </grant>\n    </permissions>\n</dds>\n'})}),"\n",(0,t.jsx)(i.h3,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Regularly rotate certificates and keys"}),"\n",(0,t.jsx)(i.li,{children:"Use separate security domains for different robot teams"}),"\n",(0,t.jsx)(i.li,{children:"Implement the principle of least privilege"}),"\n",(0,t.jsx)(i.li,{children:"Monitor security logs for suspicious activity"}),"\n",(0,t.jsx)(i.li,{children:"Keep security configurations up to date"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"what-you-learned",children:"What You Learned"}),"\n",(0,t.jsx)(i.p,{children:"In this chapter, you've explored advanced ROS 2 concepts that are essential for professional robotics development. You now understand Quality of Service policies and how to configure them for different types of communication, real-time considerations for deterministic systems, multi-robot coordination patterns, and security concepts for protecting your robotic systems. These advanced topics will help you build more robust, reliable, and secure robotic applications that meet industrial standards."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);